= Source Code Docs
Sebastian Sommerfeld <sebastian@sommerfeld.io>

// +------------------------------------------------------------------+
// |                                                                  |
// |    DO NOT EDIT HERE !!!!!                                        |
// |                                                                  |
// |    File is auto-generated by pipline.                            |
// |    See: dev-environment-config                                   |
// |        src/main/docker/source2docs/assets/index-template.adoc    |
// |                                                                  |
// +------------------------------------------------------------------+

Documentation based on the inline docs of our source code files. These pages are generated automatically to ensure they are up to date.

== Bash Script Docs
Bash scripts documentation is done inline using the documentation pattern from `link:https://github.com/reconquest/shdoc[shdoc]`. These docs pages describing bash scripts are auto-generated from a pipeline using `shdoc`.

include::AUTO-GENERATED:partial$/nav-bash.adoc[]

== Dockerfile and Docker Compose Docs
Dockerfile documentation is done inline using the documentation pattern from `link:https://github.com/reconquest/shdoc[shdoc]`. Although `shdoc` does not officially support Dockerfiles, it still works because both file types use the same comment-style (`#`). However with Dockerfiles it is only possible to document the whole file itself (since Dockerfiles do not support functions like bash scripts). These docs pages describing Dockerfiles are auto-generated from a pipeline using `shdoc`.

include::AUTO-GENERATED:partial$/nav-dockerfile.adoc[]

include::AUTO-GENERATED:partial$/nav-docker-compose.adoc[]

== Makefile
Makefile documentation is done inline using the documentation pattern from `link:https://github.com/reconquest/shdoc[shdoc]`. Although `shdoc` does not officially support Makefiles, it still works because both file types use the same comment-style (`#`). However with Makefiles it is only possible to document the whole file itself (since Makefiles do not support functions like bash scripts). These docs pages describing Makefiles are auto-generated from a pipeline using `shdoc`.

include::AUTO-GENERATED:partial$/nav-makefile.adoc[]

== Vagrant
Vagrantfile documentation is done inline using the documentation pattern from `link:https://github.com/reconquest/shdoc[shdoc]`. Although `shdoc` does not officially support Vagrantfiles, it still works because both file types use the same comment-style (`#`). However with Vagrantfile it is only possible to document the whole file itself (since Vagrantfile do not support functions like bash scripts). These docs pages describing Vagrantfile are auto-generated from a pipeline using `shdoc`.

include::AUTO-GENERATED:partial$/nav-vagrantfile.adoc[]

// == Github Actions Docs
// Github Actions workflows documentation is done inline using the documentation pattern from `link:https://github.com/reconquest/shdoc[shdoc]`. Although `shdoc` does not officially support `yml`-files, it still works because both file types use the same comment-style (`#`). However with `yml`-files it is only possible to document the whole file itself (since `yml` does not support functions like bash scripts). These docs pages describing Dockerfiles are auto-generated from a pipeline using `shdoc`.

// link:https://docs.github.com/en/actions/using-workflows/reusing-workflows[Reusing workflows] avoids duplication. Rather than copying and pasting from one workflow to another, you can make workflows reusable. You and anyone with access to the reusable workflow can then call the reusable workflow from another workflow. This makes workflows easier to maintain and allows you to create new workflows more quickly by building on the work of others, just as you do with actions. Workflow reuse also promotes best practice by helping you to use workflows that are well designed, have already been tested, and have been proven to be effective. Your organization can build up a library of reusable workflows that can be centrally maintained.

// include::AUTO-GENERATED:partial$/nav-github-actions.adoc[]

== Chef InSpec
Chef InSpec is an open-source framework for testing and auditing your applications and infrastructure. It compares the actual state of your system with the desired state that you express in easy-to-read and easy-to-write Chef InSpec code. It detects violations and displays findings in the form of a report, but puts you in control of remediation.

Chef InSpec uses profiles to audit infrastructure. An link:https://docs.chef.io/inspec/profile[InSpec profile] organizes multiple controls into a reusable artifact. You can describe your profiles with metadata, version them, pin them to specific versions of InSpec, define specific platforms that a profile can test, and define profile dependencies.

A control defines a regulatory recommendation or requirement for the state of a system. Each profile can have many controls and each control audits different aspects of a system.

Controls are written in Ruby using the InSpec DSL, which is a Ruby DSL for writing audit controls and includes audit resources that you can invoke.

include::AUTO-GENERATED:partial$/nav-inspec.adoc[]
